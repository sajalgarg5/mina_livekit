<!DOCTYPE html>
<html>
<head>
    <title>Mina AI - Audio Receiver</title>
    <style>
        body { 
            margin: 0; background: #0a0a23; font-family: 'Courier New', monospace; 
            color: #00ff00; display: flex; flex-direction: column; height: 100vh;
        }
        #header { padding: 20px; border-bottom: 1px solid #00ff00; display: flex; justify-content: space-between; }
        #log-container { 
            flex-grow: 1; overflow-y: auto; padding: 20px; font-size: 14px; line-height: 1.4;
            display: flex; flex-direction: column-reverse; /* Newest logs at top */
        }
        .log-entry { margin-bottom: 5px; border-left: 3px solid #00ff00; padding-left: 10px; }
        .log-entry.error { border-color: #ff0000; color: #ff0000; }
        .log-entry.audio { border-color: #00d2ff; color: #00d2ff; }
        
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 35, 0.95); display: flex; justify-content: center;
            align-items: center; z-index: 100;
        }
        button {
            padding: 20px 40px; font-size: 24px; background: #00ff00; color: #000;
            border: none; cursor: pointer; font-family: inherit; font-weight: bold;
        }
        #vitals { font-size: 12px; color: #888; }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="startBtn">INITIALIZE MINA AUDIO</button>
    </div>

    <div id="header">
        <div>STATUS: <span id="ws-status">DISCONNECTED</span></div>
        <div id="vitals">PACKETS: <span id="pkt-count">0</span> | LATENCY: <span id="latency">--</span>ms</div>
    </div>

    <div id="log-container" id="logs">
        </div>

    <script>
        const WS_URL = "wss://anyone-gordon-expansys-generations.trycloudflare.com/ws/rt";
        const SAMPLE_RATE = 16000;
        
        let audioCtx;
        let nextStartTime = 0;
        let socket;
        let pktCount = 0;

        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('overlay');
        const logContainer = document.getElementById('log-container');
        const wsStatus = document.getElementById('ws-status');
        const pktDisplay = document.getElementById('pkt-count');

        function screenLog(msg, type = '') {
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logContainer.prepend(div);
        }

        // AUTO-START ATTEMPT
        window.onload = () => {
            screenLog("System loaded. Waiting for user to unlock AudioContext...");
        };

        startBtn.onclick = async () => {
            overlay.style.display = 'none';
            await initAudio();
            connect();
        };

        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                screenLog("ðŸ”Š Audio System Online (" + SAMPLE_RATE + "Hz)");
            } catch (e) {
                screenLog("FAILED TO INIT AUDIO: " + e.message, "error");
            }
        }

        function connect() {
            screenLog("ðŸ”Œ Connecting to WebSocket...");
            wsStatus.textContent = "CONNECTING...";
            wsStatus.style.color = "orange";

            socket = new WebSocket(WS_URL);

            socket.onopen = () => {
                wsStatus.textContent = "CONNECTED";
                wsStatus.style.color = "#00ff00";
                screenLog("âœ… WebSocket Connected Successfully");
            };

            socket.onmessage = async (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    
                    // Specific check for the Recall.ai event structure
                    if (msg.event === "audio_mixed_raw.data") {
                        pktCount++;
                        pktDisplay.textContent = pktCount;
                        
                        // Log every 10th packet to keep screen clean but show activity
                        if (pktCount % 10 === 0) {
                            screenLog(`ðŸŽµ Stream Active: Received ${pktCount} audio chunks`, "audio");
                        }

                        if (msg.data && msg.data.data && msg.data.data.buffer) {
                            playPCM(msg.data.data.buffer);
                        }
                    } else {
                        screenLog("ðŸ“© Received Event: " + (msg.event || "unknown"));
                    }
                } catch (e) {
                    screenLog("Data error: " + e.message, "error");
                }
            };

            socket.onclose = () => {
                wsStatus.textContent = "DISCONNECTED";
                wsStatus.style.color = "red";
                screenLog("ðŸ”Œ Connection Closed. Retrying in 3s...", "error");
                setTimeout(connect, 3000);
            };

            socket.onerror = (err) => {
                screenLog("WS Error: Check console for details", "error");
            };
        }

        function playPCM(base64) {
            // Decode Base64 to ArrayBuffer
            const binary = atob(base64);
            const buffer = new Int16Array(binary.length / 2);
            const view = new DataView(new Uint8Array(Array.from(binary, c => c.charCodeAt(0))).buffer);

            for (let i = 0; i < buffer.length; i++) {
                buffer[i] = view.getInt16(i * 2, true); // true for little-endian
            }

            // Convert Int16 to Float32 for Web Audio API
            const float32 = new Float32Array(buffer.length);
            for (let i = 0; i < buffer.length; i++) {
                float32[i] = buffer[i] / 32768;
            }

            const audioBuffer = audioCtx.createBuffer(1, float32.length, SAMPLE_RATE);
            audioBuffer.getChannelData(0).set(float32);

            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioCtx.destination);

            // Time scheduling for gapless playback
            const currentTime = audioCtx.currentTime;
            if (nextStartTime < currentTime) {
                nextStartTime = currentTime;
            }
            
            source.start(nextStartTime);
            nextStartTime += audioBuffer.duration;
        }
    </script>
</body>
</html>