<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recall.ai + ElLo Agent</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #01014e 0%, #03035a 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
        }

        /* Status Indicator Animations */
        .status-indicator {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: #82baf7;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .speaking { 
            background-color: #00d2ff; 
            box-shadow: 0 0 40px #00d2ff;
            transform: scale(1.1);
        }

        .connected { background-color: #00ff88; }
        .error { background-color: #ff4d4d; }
        
        .icon { font-size: 50px; }
        #statusText { font-size: 20px; font-weight: bold; margin-bottom: 15px; letter-spacing: 1px; }

        /* Logging Box Styling */
        #logBox {
            width: 90%;
            max-width: 800px;
            height: 260px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            overflow-y: auto;
            text-align: left;
            backdrop-filter: blur(5px);
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
        .timestamp { color: #82baf7; margin-right: 8px; }
    </style>
</head>
<body>

    <div class="status-indicator" id="statusIndicator">
        <div class="icon">‚óè</div>
    </div>
    
    <div id="statusText">INITIALIZING‚Ä¶</div>
    
    <div id="logBox"></div>

<script>
/* ===================== CONFIG ===================== */
const WS_URL = "wss://connect-dev.getello.ai/ws-ello";
// const CONVERSATION_ID = "696a0d00269b9417e249745e";
const SAMPLE_RATE = 16000;

/* ===================== STATE ===================== */
let audioCtx;
let nextStartTime = 0;
let socket;
let audioPackets = 0;

/* ===================== UI HELPERS ===================== */
const statusIndicator = document.getElementById("statusIndicator");
const statusText = document.getElementById("statusText");
const logBox = document.getElementById("logBox");

function log(msg) {
    const time = new Date().toLocaleTimeString([], { hour12: false });
    const entry = document.createElement("div");
    entry.className = "log-entry";
    entry.innerHTML = `<span class="timestamp">[${time}]</span>${msg}`;
    logBox.appendChild(entry);
    logBox.scrollTop = logBox.scrollHeight;
}

function setStatus(text, cls, icon = "‚óè") {
    statusText.textContent = text.toUpperCase();
    statusIndicator.className = `status-indicator ${cls || ""}`;
    statusIndicator.innerHTML = `<div class="icon">${icon}</div>`;
}

/* ===================== INITIALIZATION ===================== */
async function init() {
    log("üöÄ Initializing Audio System...");
    try {
        // Standardize AudioContext across browsers
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext({ sampleRate: SAMPLE_RATE });

        // Required for modern browsers to allow audio playback
        if (audioCtx.state === "suspended") {
            log("‚è≥ Resuming AudioContext...");
            await audioCtx.resume();
        }

        connectWebSocket();
    } catch (err) {
        log(`‚ùå Init error: ${err.message}`);
        setStatus("INIT FAILED", "error", "‚úó");
    }
}

/* ===================== WEBSOCKET LOGIC ===================== */
function connectWebSocket() {
    log(`üîå Connecting to ElLo Server...`);
    setStatus("CONNECTING‚Ä¶", "", "‚óè");

    socket = new WebSocket(WS_URL);

    socket.onopen = () => {
        log("‚úÖ WebSocket Connection Established");
        setStatus("CONNECTED", "connected", "‚úì");

        // Uncomment and modify if the server requires a handshake
        /*
        const startSessionMsg = {
            "type": "voice-session-start",
            "conversation_id": CONVERSATION_ID
        };
        socket.send(JSON.stringify(startSessionMsg));
        log(`üì§ Sent session start for ID: ${CONVERSATION_ID}`);
        */
    };

    socket.onmessage = async (event) => {
        let msg;
        try {
            msg = JSON.parse(event);
        } catch (e) {
            // Handle raw binary messages if applicable
            return;
        }

        // Logic for handling raw audio buffers
        if (msg.type === "voice-audio-output") {
            const base64Audio = msg.audio; 

            if (base64Audio) {
                audioPackets++;
                if (audioPackets % 10 === 0) log(`üéµ Processing audio packet #${audioPackets}`);
                await playRawPCM(base64Audio);
            }
        } else {
            log(`‚ÑπÔ∏è Event: ${msg.event || "unknown"}`);
        }
    };

    socket.onerror = (err) => {
        log("‚ùå WebSocket Error detected");
        setStatus("WS ERROR", "error", "‚úó");
    };

    socket.onclose = (e) => {
        log(`üîå WS CLOSED (code=${e.code}). Reconnecting in 3s...`);
        setStatus("DISCONNECTED", "error", "‚úó");
        setTimeout(connectWebSocket, 3000);
    };
}

/* ===================== AUDIO PLAYBACK (PCM L16) ===================== */
async function playRawPCM(base64) {
    try {
        if (audioCtx.state === "suspended") await audioCtx.resume();

        // 1. Convert base64 string to binary data
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }

        // 2. Convert to Int16 array (assuming 16-bit PCM)
        const int16Buffer = new Int16Array(bytes.buffer);
        
        // 3. Normalize Int16 to Float32 (-1.0 to 1.0)
        const float32Data = new Float32Array(int16Buffer.length);
        for (let i = 0; i < int16Buffer.length; i++) {
            float32Data[i] = int16Buffer[i] / 32768.0;
        }

        // 4. Create and schedule the audio buffer
        const audioBuffer = audioCtx.createBuffer(1, float32Data.length, SAMPLE_RATE);
        audioBuffer.getChannelData(0).set(float32Data);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioCtx.destination);

        // Precise scheduling for gapless playback
        const now = audioCtx.currentTime;
        if (nextStartTime < now) nextStartTime = now;

        source.start(nextStartTime);
        nextStartTime += audioBuffer.duration;

        setStatus("AGENT SPEAKING", "speaking", "üé§");

        source.onended = () => {
            // Only revert status if we've finished the whole queue
            if (audioCtx.currentTime >= nextStartTime - 0.05) {
                setStatus("LISTENING", "connected", "‚úì");
            }
        };
    } catch (err) {
        console.error("Audio Playback Error:", err);
        log(`‚ö†Ô∏è Playback error: ${err.message}`);
    }
}

// Start the application
window.onload = init;
</script>
</body>
</html>