<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Recall.ai Real-time Audio Agent</title>
    <style>
        body { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #0c0cf8; font-family: sans-serif; color: white; }
        .status-indicator { width: 150px; height: 150px; border-radius: 50%; background-color: #82baf7; display: flex; justify-content: center; align-items: center; margin-bottom: 20px; transition: 0.3s; }
        .speaking { background-color: #00d2ff; box-shadow: 0 0 50px #00d2ff; transform: scale(1.1); }
        .icon { font-size: 60px; }
        #statusText { font-size: 18px; font-weight: bold; text-transform: uppercase; }
        #log { margin-top: 20px; font-size: 12px; width: 80%; height: 120px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; }
    </style>
</head>
<body>
    <div class="status-indicator" id="statusIndicator"><div class="icon">‚óè</div></div>
    <div id="statusText">Connecting‚Ä¶</div>
    <div id="log"></div>

<!-- <script>
const BASE_URL = "https://tel-retreat-pure-education.trycloudflare.com";
const SAMPLE_RATE = 16000;
const MIN_BUFFER_SIZE = 1280;  -->

<script>
    const BASE_URL = "https://tel-retreat-pure-education.trycloudflare.com"; 
    const SAMPLE_RATE = 16000;
    
    // Jitter Buffer Settings
    // For 16kHz, 15 chunks is usually ~300-600ms of audio safety
    const BUFFER_THRESHOLD = 15; 
    const LOOKAHEAD_MARGIN = 0.80; // 350ms lookahead to bridge network jitter

    let audioCtx;
    let nextStartTime = 0;
    let eventSource = null;
    
    // Buffer State
    let isBuffering = true;
    let bufferQueue = [];

    function resetAudioState() {
        console.log("üßπ Audio state reset");
        isBuffering = true;
        bufferQueue = [];
        nextStartTime = 0;
        const ind = document.getElementById('statusIndicator');
        if (ind) ind.classList.remove('speaking');
    }

    function initStream() {
        if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
            return;
        }
        
        resetAudioState();
        eventSource = new EventSource(`${BASE_URL}/listen_audio`);

        eventSource.onopen = () => {
            document.getElementById('statusText').textContent = "Streaming Live";
        };

        eventSource.addEventListener('audio', (event) => {
            handleIncomingAudio(event.data);
        });

        eventSource.onerror = (err) => {
            document.getElementById('statusText').textContent = "Connection Lost. Retrying...";
            if (eventSource.readyState === EventSource.CLOSED) {
                eventSource = null;
                resetAudioState();
            }
        };
    }

    function handleIncomingAudio(base64) {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
        }

        // Essential for modern browsers
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        if (isBuffering) {
            bufferQueue.push(base64);
            if (bufferQueue.length >= BUFFER_THRESHOLD) {
                isBuffering = false;
                console.log("‚ñ∂Ô∏è Buffer full, playing...");
                bufferQueue.forEach(chunk => processAndPlay(chunk));
                bufferQueue = [];
            }
        } else {
            processAndPlay(base64);
        }
    }

    function processAndPlay(base64) {
        try {
            // 1. Efficient Decoding
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Int16Array(len / 2);
            
            // Fast way to convert string to 16-bit PCM
            const uint8 = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                uint8[i] = binaryString.charCodeAt(i);
            }
            const dataView = new DataView(uint8.buffer);
            
            for (let i = 0; i < bytes.length; i++) {
                // PCM_16000 is typically Little Endian (true)
                bytes[i] = dataView.getInt16(i * 2, true);
            }

            // 2. Convert to Float32 for Web Audio
            const float32Data = new Float32Array(bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                float32Data[i] = bytes[i] / 32768.0;
            }

            const audioBuffer = audioCtx.createBuffer(1, float32Data.length, SAMPLE_RATE);
            audioBuffer.getChannelData(0).set(float32Data);

            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioCtx.destination);

            // 3. Precise Scheduling
            const now = audioCtx.currentTime;
            
            // If our timeline is behind, sync it to 'now' + margin
            if (nextStartTime < now) {
                nextStartTime = now + LOOKAHEAD_MARGIN;
            }
            
            source.start(nextStartTime);
            nextStartTime += audioBuffer.duration;

            // Visuals
            const ind = document.getElementById('statusIndicator');
            if (ind) ind.classList.add('speaking');
            
            source.onended = () => {
                if (audioCtx.currentTime >= nextStartTime - 0.05) {
                    if (ind) ind.classList.remove('speaking');
                }
            };
        } catch (e) {
            console.error("Playback error:", e);
        }
    }

    window.onload = initStream;
</script>
</body>
</html>