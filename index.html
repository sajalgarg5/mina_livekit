<!DOCTYPE html>
<html>
<head>
    <title>Recall.ai Real-time Audio Agent</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #0c0cf8 0%, #0b0beb 100%);
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        .status-indicator {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: #82baf7;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.4s ease;
        }

        .speaking {
            background-color: #00d2ff;
            box-shadow: 0 0 30px #00d2ff;
        }

        .connected {
            background-color: #00ff88;
        }

        .error {
            background-color: #ff4d4d;
        }

        .icon {
            font-size: 50px;
        }

        #statusText {
            font-size: 18px;
            margin-bottom: 10px;
        }

        #logBox {
            width: 90%;
            max-width: 800px;
            height: 260px;
            background: rgba(0,0,0,0.35);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
            text-align: left;
        }
    </style>
</head>
<body>

<div class="status-indicator" id="statusIndicator">
    <div class="icon">‚óè</div>
</div>
<div id="statusText">INITIALIZING‚Ä¶</div>
<div id="logBox"></div>

<script>
/* ===================== CONFIG ===================== */
const WS_URL = "wss://anyone-gordon-expansys-generations.trycloudflare.com/ws/rt";
const SAMPLE_RATE = 16000;

/* ===================== STATE ===================== */
let audioCtx;
let nextStartTime = 0;
let socket;
let totalMessages = 0;
let audioPackets = 0;

/* ===================== UI HELPERS ===================== */
const statusIndicator = document.getElementById("statusIndicator");
const statusText = document.getElementById("statusText");
const logBox = document.getElementById("logBox");

function log(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logBox.innerHTML += line + "<br>";
    logBox.scrollTop = logBox.scrollHeight;
}

function setStatus(text, cls, icon = "‚óè") {
    statusText.textContent = text;
    statusIndicator.className = `status-indicator ${cls || ""}`;
    statusIndicator.innerHTML = `<div class="icon">${icon}</div>`;
}

/* ===================== INIT ===================== */
async function init() {
    log("üöÄ init() called");
    log(`üåç Visibility: ${document.visibilityState}`);

    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: SAMPLE_RATE
        });

        log(`üîä AudioContext state: ${audioCtx.state}`);

        if (audioCtx.state === "suspended") {
            await audioCtx.resume();
            log("‚ñ∂Ô∏è AudioContext resumed");
        }

        connectWebSocket();

    } catch (err) {
        log(`‚ùå Init error: ${err.message}`);
        setStatus("INIT FAILED", "error", "‚úó");
    }
}

/* ===================== WEBSOCKET ===================== */
function connectWebSocket() {
    log(`üîå Connecting WebSocket ‚Üí ${WS_URL}`);
    setStatus("CONNECTING‚Ä¶", "", "‚óè");

    socket = new WebSocket(WS_URL);

    socket.onopen = () => {
        log("‚úÖ WebSocket OPEN");
        setStatus("CONNECTED", "connected", "‚úì");
    };

    socket.onmessage = async (event) => {
        totalMessages++;

        log(`üì® WS message #${totalMessages} received`);

        if (typeof event.data !== "string") {
            log("‚ö†Ô∏è Non-text WS message ignored");
            return;
        }

        let msg;
        try {
            msg = JSON.parse(event.data);
        } catch (e) {
            log("‚ùå JSON parse failed");
            return;
        }

        log(`üìÑ Event type: ${msg.event || "unknown"}`);

        if (msg.event === "audio_mixed_raw.data") {
            audioPackets++;
            const base64Buffer = msg?.data?.data?.buffer;

            if (!base64Buffer) {
                log("‚ö†Ô∏è Audio packet missing buffer");
                return;
            }

            log(`üéµ Audio packet #${audioPackets}, size=${base64Buffer.length}`);
            await playRawPCM(base64Buffer);
        }
    };

    socket.onerror = () => {
        log("‚ùå WebSocket ERROR");
        setStatus("WS ERROR", "error", "‚úó");
    };

    socket.onclose = (e) => {
        log(`üîå WS CLOSED (code=${e.code})`);
        setStatus("DISCONNECTED", "error", "‚úó");

        setTimeout(() => {
            log("üîÑ Reconnecting WebSocket‚Ä¶");
            connectWebSocket();
        }, 3000);
    };
}

/* ===================== AUDIO ===================== */
async function playRawPCM(base64) {
    try {
        if (audioCtx.state === "suspended") {
            await audioCtx.resume();
        }

        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Int16Array(len / 2);
        const view = new DataView(
            new Uint8Array([...binary].map(c => c.charCodeAt(0))).buffer
        );

        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = view.getInt16(i * 2, true);
        }

        const floats = new Float32Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            floats[i] = bytes[i] / 32768;
        }

        const buffer = audioCtx.createBuffer(1, floats.length, SAMPLE_RATE);
        buffer.getChannelData(0).set(floats);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        if (nextStartTime < now) nextStartTime = now;

        source.start(nextStartTime);
        nextStartTime += buffer.duration;

        setStatus("PLAYING AUDIO", "speaking", "üé§");

        source.onended = () => {
            if (audioCtx.currentTime >= nextStartTime - 0.1) {
                setStatus("CONNECTED", "connected", "‚úì");
            }
        };

    } catch (err) {
        log(`‚ùå Audio error: ${err.message}`);
    }
}

/* ===================== START ===================== */
window.onload = async () => {
    log("üß† window.onload fired");
    await init();
};
</script>

</body>
</html>
