<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Recall.ai Real-time Audio Agent</title>

    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #0c0cf8;
            font-family: sans-serif;
            color: white;
        }

        .status-indicator {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: #82baf7;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            transition: 0.3s;
        }

        .speaking {
            background-color: #00d2ff;
            box-shadow: 0 0 50px #00d2ff;
            transform: scale(1.1);
        }

        .icon {
            font-size: 60px;
        }

        #statusText {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }

        #log {
            margin-top: 20px;
            font-size: 12px;
            max-width: 80%;
            height: 120px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }
    </style>
</head>

<body>

    <div class="status-indicator" id="statusIndicator">
        <div class="icon">‚óè</div>
    </div>

    <div id="statusText">Connecting‚Ä¶</div>

    <div id="log"></div>

<script>
/* ------------------------------------------------------------------
   CONFIG
------------------------------------------------------------------- */
const BASE_URL = "https://tel-retreat-pure-education.trycloudflare.com";
const SAMPLE_RATE = 16000;

/* ------------------------------------------------------------------
   STATE
------------------------------------------------------------------- */
let audioCtx = null;
let nextStartTime = 0;
let eventSource = null;
let connected = false;

/* ------------------------------------------------------------------
   LOGGING
------------------------------------------------------------------- */
function log(msg) {
    const el = document.getElementById("log");
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `[${time}] ${msg}<br>`;
    el.scrollTop = el.scrollHeight;
    console.log(msg);
}

/* ------------------------------------------------------------------
   AUDIO INIT
------------------------------------------------------------------- */
function ensureAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: SAMPLE_RATE
        });
        log("üéß AudioContext created");
    }

    if (audioCtx.state === "suspended") {
        audioCtx.resume().then(() => {
            log("‚ñ∂Ô∏è AudioContext resumed");
        });
    }
}

/* ------------------------------------------------------------------
   AUDIO PLAYBACK
------------------------------------------------------------------- */
function playPCMChunk(base64) {
    try {
        ensureAudioContext();

        const binary = atob(base64);
        const buffer = new ArrayBuffer(binary.length);
        const view = new Uint8Array(buffer);

        for (let i = 0; i < binary.length; i++) {
            view[i] = binary.charCodeAt(i);
        }

        const int16 = new Int16Array(buffer);
        const float32 = new Float32Array(int16.length);

        for (let i = 0; i < int16.length; i++) {
            float32[i] = int16[i] / 32768;
        }

        const audioBuffer = audioCtx.createBuffer(
            1,
            float32.length,
            SAMPLE_RATE
        );
        audioBuffer.getChannelData(0).set(float32);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        if (nextStartTime < now) {
            nextStartTime = now;
        }

        source.start(nextStartTime);
        nextStartTime += audioBuffer.duration;

        const indicator = document.getElementById("statusIndicator");
        indicator.classList.add("speaking");

        source.onended = () => {
            if (audioCtx.currentTime >= nextStartTime - 0.05) {
                indicator.classList.remove("speaking");
            }
        };
    } catch (err) {
        log("‚ùå Audio decode error");
    }
}

/* ------------------------------------------------------------------
   SSE CONNECTION
------------------------------------------------------------------- */
function connectSSE() {
    if (eventSource) {
        eventSource.close();
    }

    log("üîå Connecting to SSE‚Ä¶");
    document.getElementById("statusText").textContent = "Connecting‚Ä¶";

    eventSource = new EventSource(`${BASE_URL}/listen_audio`);

    eventSource.onopen = () => {
        connected = true;
        log("‚úÖ SSE connected");
        document.getElementById("statusText").textContent = "Live Streaming";
    };

    eventSource.addEventListener("audio", (event) => {
        playPCMChunk(event.data);
    });

    eventSource.addEventListener("ping", () => {
        if (!connected) {
            connected = true;
            log("üíì Heartbeat received");
        }
    });

    eventSource.onerror = () => {
        if (connected) {
            log("‚ö†Ô∏è SSE disconnected, retrying‚Ä¶");
        }
        connected = false;
        document.getElementById("statusText").textContent = "Reconnecting‚Ä¶";

        eventSource.close();
        setTimeout(connectSSE, 3000);
    };
}

/* ------------------------------------------------------------------
   USER INTERACTION (IMPORTANT FOR BROWSERS)
------------------------------------------------------------------- */
window.addEventListener("click", () => {
    ensureAudioContext();
});

/* ------------------------------------------------------------------
   START
------------------------------------------------------------------- */
window.onload = () => {
    log("üöÄ Frontend loaded");
    connectSSE();
};
</script>

</body>
</html> -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Recall.ai Real-time Audio Agent</title>

    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #0c0cf8;
            font-family: sans-serif;
            color: white;
            overflow: hidden;
        }

        .status-indicator {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: #4a4af8;
            border: 4px solid #82baf7;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .speaking {
            background-color: #00d2ff;
            box-shadow: 0 0 50px #00d2ff;
            transform: scale(1.1);
            border-color: white;
        }

        .icon { font-size: 50px; }

        #statusText {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        /* Log Container Styling */
        .log-container {
            width: 85%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #log {
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            color: #00ffcc;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .log-time { color: #888; margin-right: 8px; }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            border: 1px solid white;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover { background: rgba(255,255,255,0.3); }

        .buffer-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            margin-top: 10px;
            border-radius: 2px;
        }

        #bufferFill {
            width: 0%;
            height: 100%;
            background: #00ffcc;
            transition: width 0.1s;
        }
    </style>
</head>

<body>

    <div class="status-indicator" id="statusIndicator">
        <div class="icon">‚óè</div>
    </div>

    <div id="statusText">Ready to Connect</div>
    
    <div class="log-container">
        <div id="log"></div>
        <div class="buffer-bar"><div id="bufferFill"></div></div>
    </div>

    <div class="controls">
        <button onclick="clearLogs()">Clear Logs</button>
        <button onclick="ensureAudioContext()">Enable Audio</button>
    </div>

<script>
/* ------------------------------------------------------------------
   CONFIG
------------------------------------------------------------------- */
const BASE_URL = "https://tel-retreat-pure-education.trycloudflare.com";
const SAMPLE_RATE = 16000;
// MIN_BUFFER_SIZE in bytes. 3200 bytes = ~100ms of audio at 16k mono 16bit.
const MIN_BUFFER_SIZE = 6400; 

/* ------------------------------------------------------------------
   STATE
------------------------------------------------------------------- */
let audioCtx = null;
let eventSource = null;
let connected = false;

// Queue State
let audioBuffer = new Uint8Array(0);
let isPlayingAudio = false;

/* ------------------------------------------------------------------
   LOGGING TO PAGE
------------------------------------------------------------------- */
function log(msg) {
    const logEl = document.getElementById("log");
    const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    
    const entry = document.createElement("div");
    entry.className = "log-entry";
    entry.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;
    
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
    console.log(`[${time}] ${msg}`);
}

function clearLogs() {
    document.getElementById("log").innerHTML = "";
}

/* ------------------------------------------------------------------
   AUDIO SYSTEM (QUEUE METHOD)
------------------------------------------------------------------- */
function ensureAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: SAMPLE_RATE
        });
        log("üéß AudioContext initialized at 16kHz");
    }

    if (audioCtx.state === "suspended") {
        audioCtx.resume().then(() => log("‚ñ∂Ô∏è AudioContext resumed by user"));
    }
}

/**
 * Adds incoming base64 data to the byte queue
 */
function queueAudioChunk(base64Audio) {
    try {
        ensureAudioContext();

        const binaryString = atob(base64Audio);
        const chunk = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            chunk[i] = binaryString.charCodeAt(i);
        }

        // Combine buffers
        const newBuffer = new Uint8Array(audioBuffer.length + chunk.length);
        newBuffer.set(audioBuffer);
        newBuffer.set(chunk, audioBuffer.length);
        audioBuffer = newBuffer;

        // Update visual buffer bar
        const progress = Math.min((audioBuffer.length / MIN_BUFFER_SIZE) * 100, 100);
        document.getElementById("bufferFill").style.width = progress + "%";

        // Check if we should start playing
        if (audioBuffer.length >= MIN_BUFFER_SIZE && !isPlayingAudio) {
            log(`üì¶ Buffer threshold met (${audioBuffer.length} bytes). Starting playback...`);
            playBufferedAudio();
        }
    } catch (error) {
        log(`‚ùå Decode error: ${error.message}`);
    }
}

/**
 * Handles playing the current chunk and chaining to the next
 */
async function playBufferedAudio() {
    if (audioBuffer.length === 0) {
        isPlayingAudio = false;
        document.getElementById("statusIndicator").classList.remove("speaking");
        return;
    }

    isPlayingAudio = true;
    document.getElementById("statusIndicator").classList.add("speaking");

    try {
        // Take current buffer and clear the queue
        const chunkToPlay = audioBuffer;
        audioBuffer = new Uint8Array(0);
        document.getElementById("bufferFill").style.width = "0%";

        const sampleCount = chunkToPlay.length / 2; // 16-bit = 2 bytes per sample
        const audioBufferNode = audioCtx.createBuffer(1, sampleCount, SAMPLE_RATE);
        const channelData = audioBufferNode.getChannelData(0);

        // Int16 to Float32 conversion
        const dataView = new DataView(chunkToPlay.buffer);
        for (let i = 0; i < sampleCount; i++) {
            const sample = dataView.getInt16(i * 2, true);
            channelData[i] = sample / 32768.0;
        }

        const source = audioCtx.createBufferSource();
        source.buffer = audioBufferNode;
        source.connect(audioCtx.destination);

        source.onended = () => {
            // Check if enough data accumulated during playback for the next round
            if (audioBuffer.length >= MIN_BUFFER_SIZE) {
                playBufferedAudio();
            } else {
                isPlayingAudio = false;
                document.getElementById("statusIndicator").classList.remove("speaking");
                log("‚èπÔ∏è Buffer exhausted, waiting for more data...");
            }
        };

        source.start(0);
    } catch (error) {
        log(`‚ùå Playback error: ${error.message}`);
        isPlayingAudio = false;
    }
}

/* ------------------------------------------------------------------
   SSE CONNECTION
------------------------------------------------------------------- */
function connectSSE() {
    if (eventSource) eventSource.close();

    log("üîå Connecting to SSE stream...");
    document.getElementById("statusText").textContent = "Connecting...";

    eventSource = new EventSource(`${BASE_URL}/listen_audio`);

    eventSource.onopen = () => {
        connected = true;
        log("‚úÖ SSE Connection established");
        document.getElementById("statusText").textContent = "Live Streaming";
    };

    eventSource.addEventListener("audio", (event) => {
        queueAudioChunk(event.data);
    });

    eventSource.onerror = () => {
        connected = false;
        document.getElementById("statusText").textContent = "Connection Lost";
        log("‚ö†Ô∏è SSE disconnected. Retrying in 3s...");
        eventSource.close();
        setTimeout(connectSSE, 3000);
    };
}

/* ------------------------------------------------------------------
   INITIALIZATION
------------------------------------------------------------------- */
window.onload = () => {
    log("üöÄ Application loaded");
    log("‚ÑπÔ∏è Click anywhere to enable audio auto-play");
    connectSSE();
};

window.addEventListener("click", () => {
    ensureAudioContext();
});

</script>

</body>
</html>
