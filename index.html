<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mina Audio Receiver</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .status-container {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px border rgba(255, 255, 255, 0.18);
        }
        .indicator {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #444;
            margin: 0 auto 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            transition: all 0.3s ease;
        }
        .connected { background: #00ff88; box-shadow: 0 0 20px #00ff88; }
        .speaking { background: #00d2ff; box-shadow: 0 0 30px #00d2ff; transform: scale(1.1); }
        .error { background: #ff4d4d; }
        
        #log {
            margin-top: 20px;
            width: 400px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            border-radius: 8px;
            text-align: left;
        }
    </style>
</head>
<body>

<div class="status-container">
    <div id="indicator" class="indicator">‚óè</div>
    <h2 id="status">INITIALIZING...</h2>
    <p>Waiting for WebSocket audio packets...</p>
    <div id="log"></div>
</div>

<script>
    /* --- CONFIGURATION --- */
    const WS_URL = "wss://connect-dev.getello.ai/ws-ello";
    const SAMPLE_RATE = 16000; // Linear16 16kHz

    /* --- AUDIO STATE --- */
    let audioCtx = null;
    let nextStartTime = 0;
    let socket = null;

    const indicator = document.getElementById('indicator');
    const statusText = document.getElementById('status');
    const logBox = document.getElementById('log');

    function log(msg) {
        const entry = document.createElement('div');
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logBox.appendChild(entry);
        logBox.scrollTop = logBox.scrollHeight;
    }

    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
        }
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
        }
    }

    function connect() {
        log("Connecting to WebSocket...");
        socket = new WebSocket(WS_URL);

        socket.onopen = () => {
            log("Connected to server");
            statusText.textContent = "CONNECTED / LISTENING";
            indicator.className = "indicator connected";
        };

        socket.onmessage = async (event) => {
            try {
                log("Received message:", event.data);
                const msg = JSON.parse(event.data);
                
                // Match the event key from your packet structure
                if (msg.type === "voice-audio-output") {
                    const base64Buffer = msg.audio;
                    if (base64Buffer) {
                        await playBase64PCM(base64Buffer);
                    }
                }
            } catch (e) {
                // Ignore non-JSON or malformed packets
            }
        };

        socket.onclose = () => {
            log("WebSocket closed. Retrying...");
            indicator.className = "indicator error";
            statusText.textContent = "DISCONNECTED";
            setTimeout(connect, 3000);
        };

        socket.onerror = (err) => {
            log("WebSocket Error");
            console.error(err);
        };
    }

    async function playBase64PCM(base64) {
        await initAudio();

        // 1. Decode Base64 to binary
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Int16Array(len / 2);
        
        // 2. Convert to Int16 samples (assuming Little Endian)
        for (let i = 0; i < len; i += 2) {
            const low = binaryString.charCodeAt(i);
            const high = binaryString.charCodeAt(i + 1);
            bytes[i / 2] = (high << 8) | low;
        }

        // 3. Convert Int16 to Float32 [-1.0, 1.0]
        const floats = new Float32Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            floats[i] = bytes[i] / 32768;
        }

        // 4. Create AudioBuffer and schedule playback
        const audioBuffer = audioCtx.createBuffer(1, floats.length, SAMPLE_RATE);
        audioBuffer.getChannelData(0).set(floats);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioCtx.destination);

        // Visual Feedback
        indicator.className = "indicator speaking";
        source.onended = () => {
            // Only revert if we aren't currently playing something else
            if (audioCtx.currentTime >= nextStartTime - 0.05) {
                indicator.className = "indicator connected";
            }
        };

        // Precise Scheduling (Gapless Playback)
        const currentTime = audioCtx.currentTime;
        if (nextStartTime < currentTime) {
            nextStartTime = currentTime + 0.01; // Small buffer for safety
        }

        source.start(nextStartTime);
        nextStartTime += audioBuffer.duration;
    }

    // Start on load
    window.onload = connect;

    // Browser policy: AudioContext must be resumed after a user gesture
    // document.body.addEventListener('click', initAudio, { once: true });
</script>

</body>
</html>