<!DOCTYPE html>
<html>
<head>
    <title>Recall.ai + ElLo Agent</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #0c0cf8 0%, #0b0beb 100%);
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        .status-indicator {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: #82baf7;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.4s ease;
        }
        .speaking { background-color: #00d2ff; box-shadow: 0 0 30px #00d2ff; }
        .connected { background-color: #00ff88; }
        .error { background-color: #ff4d4d; }
        .icon { font-size: 50px; }
        #statusText { font-size: 18px; margin-bottom: 10px; }
        #logBox {
            width: 90%;
            max-width: 800px;
            height: 260px;
            background: rgba(0,0,0,0.35);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
            text-align: left;
        }
    </style>
</head>
<body>

<div class="status-indicator" id="statusIndicator">
    <div class="icon">‚óè</div>
</div>
<div id="statusText">INITIALIZING‚Ä¶</div>
<div id="logBox"></div>

<script>
/* ===================== CONFIG ===================== */
// const WS_URL = "wss://connect-dev.getello.ai/ws-ello";
const WS_URL = "wss://anyone-gordon-expansys-generations.trycloudflare.com/ws/rt";
const CONVERSATION_ID = "696a0d00269b9417e249745e"; // Put your ID here
const SAMPLE_RATE = 16000;

/* ===================== STATE ===================== */
let audioCtx;
let nextStartTime = 0;
let socket;
let audioPackets = 0;

/* ===================== UI HELPERS ===================== */
const statusIndicator = document.getElementById("statusIndicator");
const statusText = document.getElementById("statusText");
const logBox = document.getElementById("logBox");

function log(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logBox.innerHTML += line + "<br>";
    logBox.scrollTop = logBox.scrollHeight;
}

function setStatus(text, cls, icon = "‚óè") {
    statusText.textContent = text;
    statusIndicator.className = `status-indicator ${cls || ""}`;
    statusIndicator.innerHTML = `<div class="icon">${icon}</div>`;
}

/* ===================== INIT ===================== */
async function init() {
    log("üöÄ Initializing Audio...");
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: SAMPLE_RATE
        });

        if (audioCtx.state === "suspended") {
            await audioCtx.resume();
        }

        connectWebSocket();
    } catch (err) {
        log(`‚ùå Init error: ${err.message}`);
        setStatus("INIT FAILED", "error", "‚úó");
    }
}

/* ===================== WEBSOCKET ===================== */
function connectWebSocket() {
    log(`üîå Connecting to ElLo WS...`);
    setStatus("CONNECTING‚Ä¶", "", "‚óè");

    socket = new WebSocket(WS_URL);

    socket.onopen = () => {
        log("‚úÖ WebSocket OPEN");
        setStatus("CONNECTED", "connected", "‚úì");

        // Logic from your Python 'sender': Send session start immediately
        // const startSessionMsg = {
        //     "type": "voice-session-start",
        //     "conversation_id": CONVERSATION_ID
        // };
        // socket.send(JSON.stringify(startSessionMsg));
        // log(`üì§ Sent voice-session-start for ID: ${CONVERSATION_ID}`);
    };

    socket.onmessage = async (event) => {
        let msg;
        try {
            msg = JSON.parse(event.data);
        } catch (e) {
            return;
        }

        // Logic from your Python 'receiver':
        // Specifically check for "voice-audio-output"
        if (msg.event === "audio_mixed_raw.data") {
            audioPackets++;
            const base64Audio = msg.data?.data?.buffer; // ElLo sends audio in the 'audio' field

            if (base64Audio) {
                if (audioPackets % 10 === 0) log(`üéµ Received audio packet #${audioPackets}`);
                await playRawPCM(base64Audio);
            }
        } else {
            // Log other messages like metadata/transcripts
            log(`‚ÑπÔ∏è Received: ${msg.event || "unknown event"}`);
        }
    };

    socket.onerror = (err) => {
        log("‚ùå WebSocket ERROR");
        setStatus("WS ERROR", "error", "‚úó");
    };

    socket.onclose = (e) => {
        log(`üîå WS CLOSED (code=${e.code}). Reconnecting in 3s...`);
        setStatus("DISCONNECTED", "error", "‚úó");
        setTimeout(connectWebSocket, 3000);
    };
}

/* ===================== AUDIO PLAYBACK ===================== */
async function playRawPCM(base64) {
    try {
        if (audioCtx.state === "suspended") await audioCtx.resume();

        // Convert base64 to Int16 PCM
        const binary = atob(base64);
        const bytes = new Int16Array(binary.length / 2);
        const dataView = new DataView(new ArrayBuffer(binary.length));
        
        for (let i = 0; i < binary.length; i++) {
            dataView.setUint8(i, binary.charCodeAt(i));
        }

        for (let i = 0; i < bytes.length; i++) {
            // Assuming Little Endian as per standard PCM streams
            bytes[i] = dataView.getInt16(i * 2, true);
        }

        // Convert Int16 to Float32 for Web Audio API
        const floats = new Float32Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            floats[i] = bytes[i] / 32768;
        }

        const buffer = audioCtx.createBuffer(1, floats.length, SAMPLE_RATE);
        buffer.getChannelData(0).set(floats);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        if (nextStartTime < now) nextStartTime = now;

        source.start(nextStartTime);
        nextStartTime += buffer.duration;

        setStatus("AGENT SPEAKING", "speaking", "üé§");

        source.onended = () => {
            if (audioCtx.currentTime >= nextStartTime - 0.1) {
                setStatus("LISTENING", "connected", "‚úì");
            }
        };
    } catch (err) {
        console.error(err);
    }
}

window.onload = init;
</script>

</body>
</html>